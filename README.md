# 自行翻译文献内存屏障
## 抽象内存访问模型
- 设备操作
- 保证可靠性

## 什么是内存屏障
- 不同种类的内存屏障
- 内存屏障有哪些没有的假设
- 数据依赖内存屏障（层级数据）
- 控制依赖关系
- SMP屏障配对
- 内存屏障序列的例子
- 读内存屏障 vs 加载内存推测
- 多重原子性

## 明确内核屏障
- 编译屏障
- CPU 内存屏障
- MMIO写屏障

## 隐式内核内存障碍 
- 锁定采集功能
- 中断禁用功能
- 睡眠和唤醒功能
- 杂项功能

## CPU间获取屏障效应
- 获取vs内存访问
- 获取与I / O访问

## 需要哪些记忆障碍
- 处理器间交互
- 原子操作
- 访问设备
- 中断

## 内核I / O屏障效果
## 假设最小执行排序模型

## cpu缓存的影响
- 缓存一致性
- 缓存一致性与DMA
- 缓存一致性与MMIO

## CPU能够做到的事情


### 抽象内存访问模型
考虑以下抽象模型系统：


```
		            :                :
		+-------+   :   +--------+   :   +-------+
		|       |   :   |        |   :   |       |
		|       |   :   |        |   :   |       |
		| CPU 1 |<----->| Memory |<----->| CPU 2 |
		|       |   :   |        |   :   |       |
		|       |   :   |        |   :   |       |
		+-------+   :   +--------+   :   +-------+
		    ^       :       ^        :       ^
		    |       :       |        :       |
		    |       :       |        :       |
		    |       :       v        :       |
		    |       :   +--------+   :       |
		    |       :   |        |   :       |
		    |       :   |        |   :       |
		    +---------->| Device |<----------+
		            :   |        |   :
		            :   |        |   :
		            :   +--------+   :
		            :                :
```
每个cpu执行访问内存的程序， 在抽象cpu中，访问内存的顺序非常随意的，并且一个cpu可能使用任何顺序访问内存，似乎这种事情得到了保持，同样，编译器可以以任何顺序发出指令，
只要它该改动明显不影响最终计划的顺利运行。


因此，在上图中，当CPU通过CPU与系统其余部分（虚线）之间的接口时，系统的其余部分会感知CPU执行的存储器操作的影响。

例如，请考虑以下事件序列：


```
	CPU 1		CPU 2
	===============	===============
	{ A == 1; B == 2 }
	A = 3;		x = B;
	B = 4;		y = A;
```

在执行途中，会产生24中不同的组合

```
	STORE A=3,	STORE B=4,	y=LOAD A->3,	x=LOAD B->4
	STORE A=3,	STORE B=4,	x=LOAD B->4,	y=LOAD A->3
	STORE A=3,	y=LOAD A->3,	STORE B=4,	x=LOAD B->4
	STORE A=3,	y=LOAD A->3,	x=LOAD B->2,	STORE B=4
	STORE A=3,	x=LOAD B->2,	STORE B=4,	y=LOAD A->3
	STORE A=3,	x=LOAD B->2,	y=LOAD A->3,	STORE B=4
	STORE B=4,	STORE A=3,	y=LOAD A->3,	x=LOAD B->4
	STORE B=4, ...
	...
```
并且能够导致4种不同的组合结果:

```
	x == 2, y == 1
	x == 2, y == 3
	x == 4, y == 1
	x == 4, y == 3
```

此外，对于一个CPU对一个store的写可能不被另一个CPU的读感应到。

例如，请考虑以下事件序列：

```
	CPU 1		CPU 2
	===============	===============
	{ A == 1, B == 2, C == 3, P == &A, Q == &C }
	B = 4;		Q = P;
	P = &B		D = *Q;
```
这里存在明显的数据依赖性，因为加载到D中的值取决于
由CPU 2从P检索的地址。在序列的最后，任何一个
以下结果是可能的：


```
	（Q ==＆A）和（D == 1）
	（Q ==＆B）和（D == 2）
	（Q ==＆B）和（D == 4）
```
需要注意的是CPU永远不会将加载C到D中，因为CPUj将在执行*Q之前加载P到Q
